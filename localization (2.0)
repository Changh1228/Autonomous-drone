#!/usr/bin/env python

import math
import sys
import json
import numpy as np
import rospy
import tf2_ros
import tf2_geometry_msgs
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from geometry_msgs.msg import PoseStamped, TransformStamped, Vector3
from aruco_msgs.msg import MarkerArray
from crazyflie_driver.msg import Position
from collections import deque

aruco_marker = None


def transform_callback(data):
    # update pose of aruco (camera_link)
    global aruco_marker
    aruco_marker = data


def read_from_marker(m):
    t = PoseStamped()
    t.header.stamp = rospy.Time.now()
    t.header.frame_id = 'map'
    t.pose.position = Vector3(*m['pose']['position'])
    roll, pitch, yaw = m['pose']['orientation']
    (t.pose.orientation.x,
     t.pose.orientation.y,
     t.pose.orientation.z,
     t.pose.orientation.w) = quaternion_from_euler(math.radians(roll),
                                                     math.radians(pitch),
                                                     math.radians(yaw))
    return t


rospy.init_node('localization')
sub_goal = rospy.Subscriber('/aruco/markers', MarkerArray, transform_callback)
tf_buf   = tf2_ros.Buffer()
tf_lstn  = tf2_ros.TransformListener(tf_buf)


def main(argv=sys.argv):
    global aruco_marker
    d_buf = None
    yaw_buf = None
    queue = deque(maxlen = 10) # make a queue length of 10
    # Load world JSON
    args = rospy.myargv(argv=argv)  # Let ROS filter through the arguments
    with open(args[1], 'rb') as f:
        world = json.load(f)

    # Get pose of aruco in map frame (accurate)
	aruco_true_pose = {m["id"]: read_from_marker(m) for m in world['markers']}

    rate = rospy.Rate(10)  # Hz
    print('running')

    i = 1  # counter for time average
    while not rospy.is_shutdown():
        if not aruco_marker:
            continue
    # ---------------do localization ----------------
        # transform pose in camera link to odm link
        aruco_detect_pose = np.array([None for i in range(16)])
        for aruco in aruco_marker.markers:
            if aruco.id > 15:
                continue
            goal = PoseStamped()
            goal.header.stamp = rospy.Time.now()
            goal.header.frame_id = "cf1/camera_link"
            goal.pose = aruco.pose.pose
            aruco_detect_pose[aruco.id] = tf_buf.transform(goal, 'cf1/odom', rospy.Duration(0.1))

        # calculate the difference (true_pose detect_pose)
        position_x = 0
        position_y = 0
        position_z = 0
        orientation_x = 0
        orientation_y = 0
        orientation_z = 0
        orientation_w = 0
        yaw = 0
        j = 0
        for i in range(16):
            if aruco_detect_pose[i] != None:
                position_x = position_x + aruco_true_pose[i].pose.position.x - aruco_detect_pose[i].pose.position.x
                position_y = position_y + aruco_true_pose[i].pose.position.y - aruco_detect_pose[i].pose.position.y
                position_z = position_z + aruco_true_pose[i].pose.position.z - aruco_detect_pose[i].pose.position.z
                orientation_x = orientation_x + aruco_true_pose[i].pose.orientation.x - aruco_detect_pose[i].pose.orientation.x
                orientation_y = orientation_y + aruco_true_pose[i].pose.orientation.y - aruco_detect_pose[i].pose.orientation.y
                orientation_z = orientation_z + aruco_true_pose[i].pose.orientation.z - aruco_detect_pose[i].pose.orientation.z
                orientation_w = orientation_w + aruco_true_pose[i].pose.orientation.w - aruco_detect_pose[i].pose.orientation.w
                j = j + 1

        position_x = position_x / j
        position_y = position_y / j
        position_z = position_z / j
        orientation_x = orientation_x / j
        orientation_y = orientation_y / j
        orientation_z = orientation_z / j
        orientation_w = orientation_w / j

        # cal time average
        queue.append([position_x, position_y, position_z, orientation_x, orientation_y, orientation_z, orientation_w])
        k = len(queue)
        timeAve_x = 0
        timeAve_y = 0
        timeAve_z = 0
        timeAve_ox = 0
        timeAve_oy = 0
        timeAve_oz = 0
        timeAve_ow = 0
        for i in queue:
            timeAve_x = timeAve_x + i[0]
            timeAve_y = timeAve_y + i[1]
            timeAve_z = timeAve_z + i[2]
            timeAve_ox = timeAve_ox + i[3]
            timeAve_oy = timeAve_oy + i[4]
            timeAve_oz = timeAve_oz + i[5]
            timeAve_ow = timeAve_ow + i[6]

        timeAve_x = timeAve_x / k
        timeAve_y = timeAve_y / k
        timeAve_z = timeAve_z / k
        timeAve_ox = timeAve_ox / k
        timeAve_oy = timeAve_oy / k
        timeAve_oz = timeAve_oz / k
        timeAve_ow = timeAve_ow / k

        d = pow(timeAve_x, 2) + pow(timeAve_y, 2)

        if not d_buf:
            d_buf = 0
            yaw_buf = 0

        if abs(d_buf-d) > 0.01 or i >= 10:
            # TF form odm to map
            br = tf2_ros.TransformBroadcaster()
            tfO2M = TransformStamped()
            tfO2M.header.stamp = rospy.Time.now()
            tfO2M.header.frame_id = "map"
            tfO2M.child_frame_id = "cf1/odom"
            tfO2M.transform.translation.x = timeAve_x
            tfO2M.transform.translation.y = timeAve_y
            tfO2M.transform.translation.z = 0.0
            tfO2M.transform.rotation.x = timeAve_ox
            tfO2M.transform.rotation.y = timeAve_oy
            tfO2M.transform.rotation.z = timeAve_oz
            tfO2M.transform.rotation.w = timeAve_ow
            br.sendTransform(tfO2M)
            print("publish tf")
            print(timeAve_x)
            d_buf = d
            i = 0

        i = i+1
        rate.sleep()

if __name__ == '__main__':
    main()
