#!/usr/bin/env python

import math
import sys
import json
import numpy as np
import rospy
import tf2_ros
import tf2_geometry_msgs
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from geometry_msgs.msg import PoseStamped, TransformStamped, Vector3
from aruco_msgs.msg import MarkerArray
from crazyflie_driver.msg import Position
from collections import deque

aruco_marker = None


def transform_callback(data):
    # update pose of aruco (camera_link)
    global aruco_marker
    aruco_marker = data


def read_from_marker(m):
    t = PoseStamped()
    t.header.stamp = rospy.Time.now()
    t.header.frame_id = 'map'
    t.pose.position = Vector3(*m['pose']['position'])
    roll, pitch, yaw = m['pose']['orientation']
    (t.pose.orientation.x,
     t.pose.orientation.y,
     t.pose.orientation.z,
     t.pose.orientation.w) = quaternion_from_euler(math.radians(roll),
                                                   math.radians(pitch),
                                                   math.radians(yaw))
    return t


rospy.init_node('localization')
sub_goal = rospy.Subscriber('/aruco/markers', MarkerArray, transform_callback)
tf_buf   = tf2_ros.Buffer()
tf_lstn  = tf2_ros.TransformListener(tf_buf)


def main(argv=sys.argv):
    global aruco_marker
    d_buf = None
    yaw_buf = None
    queue = deque(maxlen = 10) # make a queue length of 10
    # Load world JSON
    args = rospy.myargv(argv=argv)  # Let ROS filter through the arguments
    with open(args[1], 'rb') as f:
        world = json.load(f)

    # Get pose of aruco in map frame (accurate)
	aruco_map_pose = {m["id"]: read_from_marker(m) for m in world['markers']}

    rate = rospy.Rate(10)  # Hz
    print('running')

    i = 1  # counter for time average
    while not rospy.is_shutdown():
        if not aruco_marker:
            continue
    # ---------------do localization ----------------
        # transform pose in camera link to odm link
        aruco_odm_pose = np.array([None for i in range(16)])
        for aruco in aruco_marker.markers:
            if aruco.id > 15:
                continue
            goal = PoseStamped()
            goal.header.stamp = rospy.Time.now()
            goal.header.frame_id = "cf1/camera_link"
            goal.pose = aruco.pose.pose
            aruco_odm_pose[aruco.id] = tf_buf.transform(goal, 'cf1/odom', rospy.Duration(0.1))

        # calculate the difference (true_pose detect_pose)
        position_x = 0
        position_y = 0
        yaw = 0
        j = 0
        for i in range(16): # calculate average tf in markers at same time
            if aruco_odm_pose[i] != None:
                roll, pitch, yaw_map = euler_from_quaternion((aruco_map_pose[i].pose.orientation.x,
                                                              aruco_map_pose[i].pose.orientation.y,
                                                              aruco_map_pose[i].pose.orientation.z,
                                                              aruco_map_pose[i].pose.orientation.w))
                T_m2a = np.array([[math.cos(yaw_map), -math.sin(yaw_map), 0.0, aruco_map_pose[i].pose.position.x],
                                  [math.sin(yaw_map),  math.cos(yaw_map), 0.0, aruco_map_pose[i].pose.position.y],
                                  [0.0,                0.0,               1.0, aruco_map_pose[i].pose.position.z],
                                  [0.0,                0.0,               0.0,                               1.0]])

                roll, pitch, yaw_odm = euler_from_quaternion((aruco_odm_pose[i].pose.orientation.x,
                                                              aruco_odm_pose[i].pose.orientation.y,
                                                              aruco_odm_pose[i].pose.orientation.z,
                                                              aruco_odm_pose[i].pose.orientation.w))

                T_o2a = np.array([[math.cos(yaw_odm), -math.sin(yaw_odm), 0.0, aruco_odm_pose[i].pose.position.x],
                                  [math.sin(yaw_odm),  math.cos(yaw_odm), 0.0, aruco_odm_pose[i].pose.position.y],
                                  [0.0,                0.0,               1.0, aruco_odm_pose[i].pose.position.z],
                                  [0.0,                0.0,               0.0,                               1.0]])
                c = np.matmul(T_o2a, np.transpose(T_o2a))
                T_inv = np.linalg.inv(T_o2a)# np.matmul(np.transpose(T_o2a), np.linalg.inv(T_o2a))  # pseudo_inverse
                T_m2o = np.matmul(T_m2a, T_inv)
                cos_yaw = (T_m2o[0][0] + T_m2o[1][1]) / 2
                sin_yaw = (T_m2o[0][1] - T_m2o[1][0]) / 2
                print("T_o2a")
                print(T_o2a)
                print("T_m2a")
                print(T_m2a)
                print("T_m2o")
                print(T_m2o)
                yaw_error = (math.acos(cos_yaw) + math.asin(sin_yaw)) / 2

                position_x += T_m2o[0][3]
                position_y += T_m2o[1][3]
                yaw +=  yaw_error
                j = j + 1

        if j==0:
            rate.sleep()
            continue
        else:
            position_x /= j
            position_y /= j
            yaw /= j
            print("j")
            print(j)

        # cal time average
        queue.append([position_x, position_y, yaw])
        k = len(queue)
        timeAve_x = 0
        timeAve_y = 0
        timeAve_yaw = 0

        for i in queue:
            timeAve_x +=  i[0]
            timeAve_y +=  i[1]
            timeAve_yaw +=  i[2]

        timeAve_x /= k
        timeAve_y /= k
        timeAve_yaw /= k


        d = pow(timeAve_x, 2) + pow(timeAve_y, 2)

        if not d_buf:
            d_buf = 0
            yaw_buf = 0

        if abs(d_buf-d) > 0.01 or i >= 10:
            (orientation_x, orientation_y, orientation_z, orientation_w) = quaternion_from_euler(0.0001,
                                                                                                 0.0001,
                                                                                                 timeAve_yaw)
            # TF form odm to map
            br = tf2_ros.TransformBroadcaster()
            tfO2M = TransformStamped()
            tfO2M.header.stamp = rospy.Time.now()
            tfO2M.header.frame_id = "map"
            tfO2M.child_frame_id = "cf1/odom"
            tfO2M.transform.translation.x = timeAve_x
            tfO2M.transform.translation.y = timeAve_y
            tfO2M.transform.translation.z = 0.0
            tfO2M.transform.rotation.x = orientation_x
            tfO2M.transform.rotation.y = orientation_y
            tfO2M.transform.rotation.z = orientation_z
            tfO2M.transform.rotation.w = orientation_w
            br.sendTransform(tfO2M)
            print("publish tf")
            print("timeAve_yaw")
            print(timeAve_yaw)
            print("timeAve_x")
            print(timeAve_x)
            print("timeAve_y")
            print(timeAve_y)
            print("queue")
            print(queue)
            print(k)
            d_buf = d
            i = 0

        i = i+1
        rate.sleep()

if __name__ == '__main__':
    main()
